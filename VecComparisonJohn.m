function []= VecComparisonJohn(typeStr)

% typestr can be either 'ONDS', 'ONOFFDS', 'OFFDS', or 'retroONDS'.

%VecComparison

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   This script compares the vector fields obtained from the elastic model
%   with that from Shai's data. We compare the data in the four releveant
%   coordinate systems for the problem. We write the data to four seperate
%   files called
%`
%   1. angleDifUV
%   2. angleDifSTH
%   3. angleDifGSTH
%   4. angleDifXYZ
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Physical Parameters.
% This data is imported from data exported from the mapping script. These
% values correspond to measured values on the flattened retina.

phys=dlmread('phys');

R=phys(1);
M=phys(2); %This should be normalized to 1.

m1=phys(3);
m2=phys(4);
m3=phys(5);
m4=phys(6);

nu=phys(7);

a1=phys(8);
a2=phys(9);
a3=phys(10);
a4=phys(11);

%% Input vector field data from model.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   Here we input the data from the model. Speficially, we need the data
%   generated by the mapping file and the vector field scripts.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Sector1=dlmread('Sec1VecField');
Sector2=dlmread('Sec2VecField');
Sector3=dlmread('Sec3VecField');
Sector4=dlmread('Sec4VecField');


%number of points discretized over
n=size(Sector1,1);


%% Sector 1 Vector Field Data
U1=Sector1(1:n,1:n);
V1=Sector1(1:n,n+1:2*n);
VecU1=Sector1(1:n,2*n+1:3*n);
VecV1=Sector1(1:n,3*n+1:4*n);

RHO1=Sector1(1:n,4*n+1:5*n);
F1=Sector1(1:n,5*n+1:6*n);
RHOS1=Sector1(1:n,6*n+1:7*n);
RHOTH1=Sector1(1:n,7*n+1:8*n);
FS1=Sector1(1:n,8*n+1:9*n);
FTH1=Sector1(1:n,9*n+1:10*n);
S1=Sector1(1:n,10*n+1:11*n);
TH1=Sector1(1:n,11*n+1:12*n);
VecS1=Sector1(1:n,12*n+1:13*n);
VecTH1=Sector1(1:n,13*n+1:14*n);

Xprime1=Sector1(1:n,14*n+1:15*n);
Yprime1=Sector1(1:n,15*n+1:16*n);
VecXprime1=Sector1(1:n,16*n+1:17*n);
VecYprime1=Sector1(1:n,17*n+1:18*n);

X1=Sector1(1:n,18*n+1:19*n);
Y1=Sector1(1:n,19*n+1:20*n);
Z1=Sector1(1:n,20*n+1:21*n);
VecX1=Sector1(1:n,21*n+1:22*n);
VecY1=Sector1(1:n,22*n+1:23*n);
VecZ1=Sector1(1:n,23*n+1:24*n);

%% Sector 2 Vector Field Data
U2=Sector2(1:n,1:n);
V2=Sector2(1:n,n+1:2*n);
VecU2=Sector2(1:n,2*n+1:3*n);
VecV2=Sector2(1:n,3*n+1:4*n);

RHO2=Sector2(1:n,4*n+1:5*n);
F2=Sector2(1:n,5*n+1:6*n);
RHOS2=Sector2(1:n,6*n+1:7*n);
RHOTH2=Sector2(1:n,7*n+1:8*n);
FS2=Sector2(1:n,8*n+1:9*n);
FTH2=Sector2(1:n,9*n+1:10*n);
S2=Sector2(1:n,10*n+1:11*n);
TH2=Sector2(1:n,11*n+1:12*n);
VecS2=Sector2(1:n,12*n+1:13*n);
VecTH2=Sector2(1:n,13*n+1:14*n);

Xprime2=Sector2(1:n,14*n+1:15*n);
Yprime2=Sector2(1:n,15*n+1:16*n);
VecXprime2=Sector2(1:n,16*n+1:17*n);
VecYprime2=Sector2(1:n,17*n+1:18*n);

X2=Sector2(1:n,18*n+1:19*n);
Y2=Sector2(1:n,19*n+1:20*n);
Z2=Sector2(1:n,20*n+1:21*n);
VecX2=Sector2(1:n,21*n+1:22*n);
VecY2=Sector2(1:n,22*n+1:23*n);
VecZ2=Sector2(1:n,23*n+1:24*n);

%% Sector 3 Vector Field Data
U3=Sector3(1:n,1:n);
V3=Sector3(1:n,n+1:2*n);
VecU3=Sector3(1:n,2*n+1:3*n);
VecV3=Sector3(1:n,3*n+1:4*n);

RHO3=Sector3(1:n,4*n+1:5*n);
F3=Sector3(1:n,5*n+1:6*n);
RHOS3=Sector3(1:n,6*n+1:7*n);
RHOTH3=Sector3(1:n,7*n+1:8*n);
FS3=Sector3(1:n,8*n+1:9*n);
FTH3=Sector3(1:n,9*n+1:10*n);
S3=Sector3(1:n,10*n+1:11*n);
TH3=Sector3(1:n,11*n+1:12*n);
VecS3=Sector3(1:n,12*n+1:13*n);
VecTH3=Sector3(1:n,13*n+1:14*n);

Xprime3=Sector3(1:n,14*n+1:15*n);
Yprime3=Sector3(1:n,15*n+1:16*n);
VecXprime3=Sector3(1:n,16*n+1:17*n);
VecYprime3=Sector3(1:n,17*n+1:18*n);

X3=Sector3(1:n,18*n+1:19*n);
Y3=Sector3(1:n,19*n+1:20*n);
Z3=Sector3(1:n,20*n+1:21*n);
VecX3=Sector3(1:n,21*n+1:22*n);
VecY3=Sector3(1:n,22*n+1:23*n);
VecZ3=Sector3(1:n,23*n+1:24*n);

%% Sector 4 Vector Field Data
U4=Sector4(1:n,1:n);
V4=Sector4(1:n,n+1:2*n);
VecU4=Sector4(1:n,2*n+1:3*n);
VecV4=Sector4(1:n,3*n+1:4*n);

RHO4=Sector4(1:n,4*n+1:5*n);
F4=Sector4(1:n,5*n+1:6*n);
RHOS4=Sector4(1:n,6*n+1:7*n);
RHOTH4=Sector4(1:n,7*n+1:8*n);
FS4=Sector4(1:n,8*n+1:9*n);
FTH4=Sector4(1:n,9*n+1:10*n);
S4=Sector4(1:n,10*n+1:11*n);
TH4=Sector4(1:n,11*n+1:12*n);
VecS4=Sector4(1:n,12*n+1:13*n);
VecTH4=Sector4(1:n,13*n+1:14*n);

Xprime4=Sector4(1:n,14*n+1:15*n);
Yprime4=Sector4(1:n,15*n+1:16*n);
VecXprime4=Sector4(1:n,16*n+1:17*n);
VecYprime4=Sector4(1:n,17*n+1:18*n);

X4=Sector4(1:n,18*n+1:19*n);
Y4=Sector4(1:n,19*n+1:20*n);
Z4=Sector4(1:n,20*n+1:21*n);
VecX4=Sector4(1:n,21*n+1:22*n);
VecY4=Sector4(1:n,22*n+1:23*n);
VecZ4=Sector4(1:n,23*n+1:24*n);

hold on;
scale=.2;
quiver(S1,TH1,VecS1,VecTH1)
quiver(S2,TH2,VecS2,VecTH2)
quiver(S3,TH3,VecS3,VecTH3)
quiver(S4,TH4,VecS4,VecTH4)

hold off;
%% Collection from Shai's data

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   We now input measured Data from the retina in the flattened
%   coordinates.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [filedir,go]=bbdirselector('select data folder',cd);
% if ~go disp('no folder selected'); return; end
% 
% namesMap=getFileList(filedir,'map_',0,'anywhere');
% for i=1:size(namesMap,2)
%     if strfind(namesMap{i},'.mat')
%         load(num2str(namesMap{i}));
%     end
% end

load('map_May_27_2014_2.mat');

data=map.SzMapOutputDS;

Utemp=data(:,1);
Vtemp=data(:,2);
VecUtemp=data(:,3);
VecVtemp=data(:,4);
Sec=data(:,5);

switch typeStr
    case 'ONDS'
        type=map.ONDS;
    case 'ONOFFDS'
        type=map.ONOFFDS;
    case 'OFFDS'
        type=map.OFFDS;
    case 'retroONDS'
        type=map.retroONDS;
end


n=size(Utemp,1);


i=0;

%% Locating closest point on numerical mesh, converting to other vector fields and calculating angular difference.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   We now locate the point on the discrete mesh that is closest to the
%   point in Shai's data. We can take the closest point in the l^2 norm. We
%   record the index of the data points in the variables a(i), b(i) which
%   we can use to find the cooresponding point in other coordinate
%   systems. We then convert the data to other coordinate systems and
%   record the angle between the measured data and the hypothesized model.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

figure;
hold on;
surf(U1,V1,zeros(40,40));
surf(U2,V2,zeros(40,40));
surf(U3,V3,zeros(40,40));
surf(U4,V4,zeros(40,40));

for j=1:n,
    
    if type(j)==1
        i=i+1;
        
        U(i)=Utemp(j);
        V(i)=Vtemp(j);
        VecU(i)=VecUtemp(j);
        VecV(i)=VecVtemp(j);
        if Sec(j)==1,
            
            %Calculation of closest grid point.
            temp=(U(i)-U1).^2+(V(i)-V1).^2;
            [ind1,ind2] =find(temp==min(min(temp)));
            a(i)=ind1(1);
            b(i)=ind2(1);
            
            %Generation of vectors to compare with
            Ucomp(i)=U1(a(i),b(i));
            Vcomp(i)=V1(a(i),b(i));
            
            plot(Ucomp(i),Vcomp(i),'or',U(i),V(i),'ob');
            
           
            VecUcomp(i)=VecU1(a(i),b(i));
            VecVcomp(i)=VecV1(a(i),b(i));
            
            %Converting to other coordinate systems
            S(i)=S1(a(i),b(i));
            TH(i)=TH1(a(i),b(i));
            
            Xprime(i)=Xprime1(a(i),b(i));
            Yprime(i)=Yprime1(a(i),b(i));
            
            X(i)=X1(a(i),b(i));
            Y(i)=Y1(a(i),b(i));
            Z(i)=Z1(a(i),b(i));
            
            %Conversion to other vector fields. 
            [g1,g2] = InverseVec(VecU(i),VecV(i),RHO1(a(i),b(i)),F1(a(i),b(i)),RHOS1(a(i),b(i)),FS1(a(i),b(i)),RHOTH1(a(i),b(i)),FTH1(a(i),b(i)));
            
            VecS(i)=g1;
            VecTH(i)=g2;
            
            VecScomp(i)=VecS1(a(i),b(i));
            VecTHcomp(i)=VecTH1(a(i),b(i));
            
            VecXprime(i)=cos(TH(i)).*VecS(i)-S(i).*sin(TH(i)).*VecTH(i);
            VecYprime(i)=sin(TH(i)).*VecS(i)+S(i).*cos(TH(i)).*VecTH(i);
            
            VecXprimecomp(i)=VecXprime1(a(i),b(i));
            VecYprimecomp(i)=VecYprime1(a(i),b(i));
            
            VecX(i)=VecS(i).*cos(S(i)/R).*cos(TH(i))-R*VecTH(i).*sin(S(i)/R).*sin(TH(i));
            VecY(i)=VecS(i).*cos(S(i)/R).*sin(TH(i))+R*VecTH(i).*sin(S(i)/R).*cos(TH(i));
            VecZ(i)=VecS(i).*sin(S(i)/R);
            
            VecXcomp(i)=VecX1(a(i),b(i));
            VecYcomp(i)=VecY1(a(i),b(i));
            VecZcomp(i)=VecZ1(a(i),b(i));
            
        elseif Sec(j)==2,
            
            %Calculation of closest grid point.
            temp=(U(i)-U2).^2+(V(i)-V2).^2;
            [ind1,ind2] =find(temp==min(min(temp)));
            a(i)=ind1(1);
            b(i)=ind2(1);
            
            %Generation of vectors to compare with
            Ucomp(i)=U2(a(i),b(i));
            Vcomp(i)=V2(a(i),b(i));
            
            plot(Ucomp(i),Vcomp(i),'or',U(i),V(i),'ob');
            
            
            VecUcomp(i)=VecU2(a(i),b(i));
            VecVcomp(i)=VecV2(a(i),b(i));
            
            %Converting to other coordinate systems
            S(i)=S2(a(i),b(i));
            TH(i)=TH2(a(i),b(i));
            
            Xprime(i)=Xprime2(a(i),b(i));
            Yprime(i)=Yprime2(a(i),b(i));
            
            X(i)=X2(a(i),b(i));
            Y(i)=Y2(a(i),b(i));
            Z(i)=Z2(a(i),b(i));
            
            %Conversion to other vector fields. 
            [g1,g2] = InverseVec(VecU(i),VecV(i),RHO2(a(i),b(i)),F2(a(i),b(i)),RHOS2(a(i),b(i)),FS2(a(i),b(i)),RHOTH2(a(i),b(i)),FTH2(a(i),b(i)));
            
            VecS(i)=g1;
            VecTH(i)=g2;
            
            VecScomp(i)=VecS2(a(i),b(i));
            VecTHcomp(i)=VecTH2(a(i),b(i));
            
            VecXprime(i)=cos(TH(i)).*VecS(i)-S(i).*sin(TH(i)).*VecTH(i);
            VecYprime(i)=sin(TH(i)).*VecS(i)+S(i).*cos(TH(i)).*VecTH(i);
            
            VecXprimecomp(i)=VecXprime2(a(i),b(i));
            VecYprimecomp(i)=VecYprime2(a(i),b(i));
            
            VecX(i)=VecS(i).*cos(S(i)/R).*cos(TH(i))-R*VecTH(i).*sin(S(i)/R).*sin(TH(i));
            VecY(i)=VecS(i).*cos(S(i)/R).*sin(TH(i))+R*VecTH(i).*sin(S(i)/R).*cos(TH(i));
            VecZ(i)=VecS(i).*sin(S(i)/R);
            
            VecXcomp(i)=VecX2(a(i),b(i));
            VecYcomp(i)=VecY2(a(i),b(i));
            VecZcomp(i)=VecZ2(a(i),b(i));
            
            
        elseif Sec(j)==3,
            %Calculation of closest grid point.
            temp=(U(i)-U3).^2+(V(i)-V3).^2;
            [ind1,ind2] =find(temp==min(min(temp)));
            a(i)=ind1(1);
            b(i)=ind2(1);
            
            %Generation of vectors to compare with
            Ucomp(i)=U3(a(i),b(i));
            Vcomp(i)=V3(a(i),b(i));
            
            plot(Ucomp(i),Vcomp(i),'or',U(i),V(i),'ob');
            
            VecUcomp(i)=VecU3(a(i),b(i));
            VecVcomp(i)=VecV3(a(i),b(i));
            
            %Converting to other coordinate systems
            S(i)=S3(a(i),b(i));
            TH(i)=TH3(a(i),b(i));
            
            Xprime(i)=Xprime3(a(i),b(i));
            Yprime(i)=Yprime3(a(i),b(i));
            
            X(i)=X3(a(i),b(i));
            Y(i)=Y3(a(i),b(i));
            Z(i)=Z3(a(i),b(i));
            
            %Conversion to other vector fields. 
            [g1,g2] = InverseVec(VecU(i),VecV(i),RHO3(a(i),b(i)),F3(a(i),b(i)),RHOS3(a(i),b(i)),FS3(a(i),b(i)),RHOTH3(a(i),b(i)),FTH3(a(i),b(i)));
            
            VecS(i)=g1;
            VecTH(i)=g2;
            
            VecScomp(i)=VecS3(a(i),b(i));
            VecTHcomp(i)=VecTH3(a(i),b(i));
            
            VecXprime(i)=cos(TH(i)).*VecS(i)-S(i).*sin(TH(i)).*VecTH(i);
            VecYprime(i)=sin(TH(i)).*VecS(i)+S(i).*cos(TH(i)).*VecTH(i);
            
            VecXprimecomp(i)=VecXprime3(a(i),b(i));
            VecYprimecomp(i)=VecYprime3(a(i),b(i));
            
            VecX(i)=VecS(i).*cos(S(i)/R).*cos(TH(i))-R*VecTH(i).*sin(S(i)/R).*sin(TH(i));
            VecY(i)=VecS(i).*cos(S(i)/R).*sin(TH(i))+R*VecTH(i).*sin(S(i)/R).*cos(TH(i));
            VecZ(i)=VecS(i).*sin(S(i)/R);
            
            VecXcomp(i)=VecX3(a(i),b(i));
            VecYcomp(i)=VecY3(a(i),b(i));
            VecZcomp(i)=VecZ3(a(i),b(i));
         
        elseif Sec(j)==4,
            %Calculation of closest grid point.
            temp=(U(i)-U4).^2+(V(i)-V4).^2;
            [ind1,ind2] =find(temp==min(min(temp)));
            a(i)=ind1(1);
            b(i)=ind2(1);
            min(min(temp))
            %Generation of vectors to compare with
            Ucomp(i)=U4(a(i),b(i));
            Vcomp(i)=V4(a(i),b(i));
            
            plot(Ucomp(i),Vcomp(i),'or',U(i),V(i),'ob');
            VecUcomp(i)=VecU4(a(i),b(i));
            VecVcomp(i)=VecV4(a(i),b(i));
            
            %Converting to other coordinate systems
            S(i)=S4(a(i),b(i));
            TH(i)=TH4(a(i),b(i));
            
            Xprime(i)=Xprime4(a(i),b(i));
            Yprime(i)=Yprime4(a(i),b(i));
            
            X(i)=X4(a(i),b(i));
            Y(i)=Y4(a(i),b(i));
            Z(i)=Z4(a(i),b(i));
            
            %Conversion to other vector fields. 
            [g1,g2] = InverseVec(VecU(i),VecV(i),RHO4(a(i),b(i)),F4(a(i),b(i)),RHOS4(a(i),b(i)),FS4(a(i),b(i)),RHOTH4(a(i),b(i)),FTH4(a(i),b(i)));
            
            VecS(i)=g1;
            VecTH(i)=g2;
            
            VecScomp(i)=VecS4(a(i),b(i));
            VecTHcomp(i)=VecTH4(a(i),b(i));
            
            VecXprime(i)=cos(TH(i)).*VecS(i)-S(i).*sin(TH(i)).*VecTH(i);
            VecYprime(i)=sin(TH(i)).*VecS(i)+S(i).*cos(TH(i)).*VecTH(i);
            
            VecXprimecomp(i)=VecXprime4(a(i),b(i));
            VecYprimecomp(i)=VecYprime4(a(i),b(i));
            
            VecX(i)=VecS(i).*cos(S(i)/R).*cos(TH(i))-R*VecTH(i).*sin(S(i)/R).*sin(TH(i));
            VecY(i)=VecS(i).*cos(S(i)/R).*sin(TH(i))+R*VecTH(i).*sin(S(i)/R).*cos(TH(i));
            VecZ(i)=VecS(i).*sin(S(i)/R);
            
            VecXcomp(i)=VecX4(a(i),b(i));
            VecYcomp(i)=VecY4(a(i),b(i));
            VecZcomp(i)=VecZ4(a(i),b(i));
            
            
        end
    end
end

%% Normalizing Vector Fields
temp=(VecU.^2+VecV.^2).^(1/2);
VecU=VecU./temp;
VecV=VecV./temp;

temp=(VecUcomp.^2+VecVcomp.^2).^(1/2);
VecUcomp=VecUcomp./temp;
VecVcomp=VecVcomp./temp;

temp=(VecS.^2+VecTH.^2).^(1/2);
VecS=VecS./temp;
VecTH=VecTH./temp;

temp=(VecScomp.^2+VecTHcomp.^2).^(1/2);
VecScomp=VecScomp./temp;
VecTHcomp=VecTHcomp./temp;

temp=(VecXprime.^2+VecYprime.^2).^(1/2);
VecXprime=VecXprime./temp;
VecYprime=VecYprime./temp;

temp=(VecXprimecomp.^2+VecYprimecomp.^2).^(1/2);
VecXprimecomp=VecXprimecomp./temp;
VecYprimecomp=VecYprimecomp./temp;

temp=(VecX.^2+VecY.^2+VecZ.^2).^(1/2);
VecX=VecX./temp;
VecY=VecY./temp;
VecZ=VecZ./temp;

temp=(VecXcomp.^2+VecYcomp.^2+VecZcomp.^2).^(1/2);
VecXcomp=VecXcomp./temp;
VecYcomp=VecYcomp./temp;
VecZcomp=VecZcomp./temp;


%% Computing Angles Between Vectors

angleUV=acos(VecU.*VecUcomp+VecV.*VecVcomp);
angleSTH=acos(VecS.*VecScomp+VecTH.*VecTHcomp);
angleSTHGen=acos(VecXprime.*VecXprimecomp+VecYprime.*VecYprimecomp);
angleXYZ=acos(VecX.*VecXcomp+VecY.*VecYcomp+VecZ.*VecZcomp);

dlmwrite('angleUVdif',angleUV);
dlmwrite('angleSTHdif',angleSTH);
dlmwrite('angleSTHGendif',angleSTHGen);
dlmwrite('angleXYZdif',angleXYZ);

%Plotting vector fields in UV coordinates
figure;
hold on;

scale=0.2;
quiver(Ucomp,Vcomp,VecUcomp,VecVcomp,scale);
quiver(U,V,VecU,VecV,scale);
hold off;

% figure;
% hold on;
% 
% surf(U1,V1,zeros(40,40));
% surf(U2,V2,zeros(40,40));
% surf(U3,V3,zeros(40,40));
% surf(U4,V4,zeros(40,40));
% scale=0.2;
% quiver(Ucomp,Vcomp,VecUcomp,VecVcomp);
% quiver(U,V,VecU,VecV,scale);
% hold off;


%Plotting vector fields in STH coordinates
figure;
hold on;
scale=.2;
quiver(S,TH,VecScomp,VecTHcomp,scale);
%quiver(S,TH,VecS,VecTH,scale);
hold off;

%Plotting vector fields in generalized (S,TH) coordinates
figure;
hold on;
scale=.2;
quiver(Xprime,Yprime,VecXprimecomp,VecYprimecomp,scale);
quiver(Xprime,Yprime,VecXprime,VecYprime,scale);
% hold off;

%Plotting vector fields in generalized (X,Y,Z) coordinates
figure;
hold on;
scale=.2;
quiver3(X,Y,Z,VecXcomp,VecYcomp,VecZcomp,scale);
quiver3(X,Y,Z,VecX,VecY,VecZ,scale);
hold off;

end

