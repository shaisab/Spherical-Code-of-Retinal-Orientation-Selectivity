function []= VecComparison(discPoints,cellType,fieldType)

% cellType can be either 'ONDS', 'ONOFFDS', 'OFFDS', or 'retroONDS'.
% fieldType can be either 'ASC', 'PSC', 'LSC', 'cardinalUp', etc.
%VecComparison

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   This script compares the vector fields obtained from the elastic model
%   with that from Shai's data. We compare the data in the four releveant
%   coordinate systems for the problem. We write the data to four seperate
%   files called
%
%   1. angleDifUV
%   2. angleDifSTH
%   3. angleDifGSTH
%   4. angleDifXYZ
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Physical Parameters.
% This data is imported from data exported from the mapping script. These
% values correspond to measured values on the flattened retina.

phys=dlmread('phys');

R=phys(1);
M=phys(2); %This should be normalized to 1.

m1=phys(3);
m2=phys(4);
m3=phys(5);
m4=phys(6);

nu=phys(7);

a1=phys(8);
a2=phys(9);
a3=phys(10);
a4=phys(11);

%% Input vector field data from model.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   Here we input the data from the model. Speficially, we need the data
%   generated by the mapping file and the vector field scripts.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
try
Sector1=dlmread(['Sec1VecField_',num2str(discPoints),'_',fieldType]);
Sector2=dlmread(['Sec2VecField_',num2str(discPoints),'_',fieldType]);
Sector3=dlmread(['Sec3VecField_',num2str(discPoints),'_',fieldType]);
Sector4=dlmread(['Sec4VecField_',num2str(discPoints),'_',fieldType]);
catch
    disp('no such vector field exist');
    return
end

%number of points discretized over
n=size(Sector1,1);

%% Sector 1 Vector Field Data
U1=Sector1(1:n,1:n);
V1=Sector1(1:n,n+1:2*n);
VecU1=Sector1(1:n,2*n+1:3*n);
VecV1=Sector1(1:n,3*n+1:4*n);

RHO1=Sector1(1:n,4*n+1:5*n);
F1=Sector1(1:n,5*n+1:6*n);
RHOS1=Sector1(1:n,6*n+1:7*n);
RHOTH1=Sector1(1:n,7*n+1:8*n);
FS1=Sector1(1:n,8*n+1:9*n);
FTH1=Sector1(1:n,9*n+1:10*n);
S1=Sector1(1:n,10*n+1:11*n);
TH1=Sector1(1:n,11*n+1:12*n);
VecS1=Sector1(1:n,12*n+1:13*n);
VecTH1=Sector1(1:n,13*n+1:14*n);

Xprime1=Sector1(1:n,14*n+1:15*n);
Yprime1=Sector1(1:n,15*n+1:16*n);
VecXprime1=Sector1(1:n,16*n+1:17*n);
VecYprime1=Sector1(1:n,17*n+1:18*n);

X1=Sector1(1:n,18*n+1:19*n);
Y1=Sector1(1:n,19*n+1:20*n);
Z1=Sector1(1:n,20*n+1:21*n);
VecX1=Sector1(1:n,21*n+1:22*n);
VecY1=Sector1(1:n,22*n+1:23*n);
VecZ1=Sector1(1:n,23*n+1:24*n);

%% Sector 2 Vector Field Data
U2=Sector2(1:n,1:n);
V2=Sector2(1:n,n+1:2*n);
VecU2=Sector2(1:n,2*n+1:3*n);
VecV2=Sector2(1:n,3*n+1:4*n);

RHO2=Sector2(1:n,4*n+1:5*n);
F2=Sector2(1:n,5*n+1:6*n);
RHOS2=Sector2(1:n,6*n+1:7*n);
RHOTH2=Sector2(1:n,7*n+1:8*n);
FS2=Sector2(1:n,8*n+1:9*n);
FTH2=Sector2(1:n,9*n+1:10*n);
S2=Sector2(1:n,10*n+1:11*n);
TH2=Sector2(1:n,11*n+1:12*n);
VecS2=Sector2(1:n,12*n+1:13*n);
VecTH2=Sector2(1:n,13*n+1:14*n);

Xprime2=Sector2(1:n,14*n+1:15*n);
Yprime2=Sector2(1:n,15*n+1:16*n);
VecXprime2=Sector2(1:n,16*n+1:17*n);
VecYprime2=Sector2(1:n,17*n+1:18*n);

X2=Sector2(1:n,18*n+1:19*n);
Y2=Sector2(1:n,19*n+1:20*n);
Z2=Sector2(1:n,20*n+1:21*n);
VecX2=Sector2(1:n,21*n+1:22*n);
VecY2=Sector2(1:n,22*n+1:23*n);
VecZ2=Sector2(1:n,23*n+1:24*n);

%% Sector 3 Vector Field Data
U3=Sector3(1:n,1:n);
V3=Sector3(1:n,n+1:2*n);
VecU3=Sector3(1:n,2*n+1:3*n);
VecV3=Sector3(1:n,3*n+1:4*n);

RHO3=Sector3(1:n,4*n+1:5*n);
F3=Sector3(1:n,5*n+1:6*n);
RHOS3=Sector3(1:n,6*n+1:7*n);
RHOTH3=Sector3(1:n,7*n+1:8*n);
FS3=Sector3(1:n,8*n+1:9*n);
FTH3=Sector3(1:n,9*n+1:10*n);
S3=Sector3(1:n,10*n+1:11*n);
TH3=Sector3(1:n,11*n+1:12*n);
VecS3=Sector3(1:n,12*n+1:13*n);
VecTH3=Sector3(1:n,13*n+1:14*n);

Xprime3=Sector3(1:n,14*n+1:15*n);
Yprime3=Sector3(1:n,15*n+1:16*n);
VecXprime3=Sector3(1:n,16*n+1:17*n);
VecYprime3=Sector3(1:n,17*n+1:18*n);

X3=Sector3(1:n,18*n+1:19*n);
Y3=Sector3(1:n,19*n+1:20*n);
Z3=Sector3(1:n,20*n+1:21*n);
VecX3=Sector3(1:n,21*n+1:22*n);
VecY3=Sector3(1:n,22*n+1:23*n);
VecZ3=Sector3(1:n,23*n+1:24*n);

%% Sector 4 Vector Field Data
U4=Sector4(1:n,1:n);
V4=Sector4(1:n,n+1:2*n);
VecU4=Sector4(1:n,2*n+1:3*n);
VecV4=Sector4(1:n,3*n+1:4*n);

RHO4=Sector4(1:n,4*n+1:5*n);
F4=Sector4(1:n,5*n+1:6*n);
RHOS4=Sector4(1:n,6*n+1:7*n);
RHOTH4=Sector4(1:n,7*n+1:8*n);
FS4=Sector4(1:n,8*n+1:9*n);
FTH4=Sector4(1:n,9*n+1:10*n);
S4=Sector4(1:n,10*n+1:11*n);
TH4=Sector4(1:n,11*n+1:12*n);
VecS4=Sector4(1:n,12*n+1:13*n);
VecTH4=Sector4(1:n,13*n+1:14*n);

Xprime4=Sector4(1:n,14*n+1:15*n);
Yprime4=Sector4(1:n,15*n+1:16*n);
VecXprime4=Sector4(1:n,16*n+1:17*n);
VecYprime4=Sector4(1:n,17*n+1:18*n);

X4=Sector4(1:n,18*n+1:19*n);
Y4=Sector4(1:n,19*n+1:20*n);
Z4=Sector4(1:n,20*n+1:21*n);
VecX4=Sector4(1:n,21*n+1:22*n);
VecY4=Sector4(1:n,22*n+1:23*n);
VecZ4=Sector4(1:n,23*n+1:24*n);

%% Collection from Shai's data

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   We now input measured Data from the retina in the flattened
%   coordinates.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [filedir,go]=bbdirselector('select data folder',cd);
% if ~go disp('no folder selected'); return; end
filedir=cd;

namesMap=getFileList(filedir,'map_',0,'anywhere');
for i=1:size(namesMap,2)
    if strfind(namesMap{i},'.mat')
        load(num2str(namesMap{i}));
    end
end

%load('map_May_27_2014_2.mat');

injectionSite=map.injectionSite;
data=map.SzMapOutputDS;

Utemp=data(:,1);
Vtemp=data(:,2);
VecUtemp=data(:,3);
VecVtemp=data(:,4);
Sec=data(:,5);

switch cellType
    case 'DS'
        type=map.isDS;
    case 'ONDS'
        type=map.ONDS;
    case 'ONOFFDS'
        type=map.ONOFFDS;
    case 'OFFDS'
        type=map.OFFDS;
    case 'retroONDS'
        type=map.isRetro;    
%     case 'retroONDS'
%         type=map.retroONDS;
end


n=size(Utemp,1);


i=0;

%% Locating closest point on numerical mesh, converting to other vector fields and calculating angular difference.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   We now locate the point on the discrete mesh that is closest to the
%   point in Shai's data. We can take the closest point in the l^2 norm. We
%   record the index of the data points in the variables a(i), b(i) which
%   we can use to find the cooresponding point in other coordinate
%   systems. We then convert the data to other coordinate systems and
%   record the angle between the measured data and the hypothesized model.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

figure;
hold on;
surf(U1,V1,zeros(size(U1,1),size(U1,1)), 'EdgeColor', 'none');
surf(U2,V2,zeros(size(U2,1),size(U2,1)), 'EdgeColor', 'none');
surf(U3,V3,zeros(size(U3,1),size(U3,1)), 'EdgeColor', 'none');
surf(U4,V4,zeros(size(U4,1),size(U4,1)), 'EdgeColor', 'none');

for j=1:n,
    
    if type(j)==1
        i=i+1;
        
        U(i)=Utemp(j);
        V(i)=Vtemp(j);
        VecU(i)=VecUtemp(j);
        VecV(i)=VecVtemp(j);
        
        if Sec(j)==1,
            
            %Calculation of closest grid point.
            temp=(U(i)-U1).^2+(V(i)-V1).^2;
            [ind1,ind2] =find(temp==min(min(temp)));
            a(i)=ind1(1);
            b(i)=ind2(1);
            
            %Generation of vectors to compare with
            Ucomp(i)=U1(a(i),b(i));
            Vcomp(i)=V1(a(i),b(i));
            
            
            plot(Ucomp(i),Vcomp(i),'or',U(i),V(i),'ob');
            
            %Moving data to point on the mesh
            U(i)=Ucomp(i);
            V(i)=Vcomp(i);
            
            VecUcomp(i)=VecU1(a(i),b(i));
            VecVcomp(i)=VecV1(a(i),b(i));
            
            %Converting to other coordinate systems
            S(i)=S1(a(i),b(i));
            TH(i)=TH1(a(i),b(i));
            
            Xprime(i)=Xprime1(a(i),b(i));
            Yprime(i)=Yprime1(a(i),b(i));
            
            X(i)=X1(a(i),b(i));
            Y(i)=Y1(a(i),b(i));
            Z(i)=Z1(a(i),b(i));
            
            %Conversion to other vector fields. 
            [g1,g2] = InverseVec(VecU(i),VecV(i),RHO1(a(i),b(i)),F1(a(i),b(i)),RHOS1(a(i),b(i)),FS1(a(i),b(i)),RHOTH1(a(i),b(i)),FTH1(a(i),b(i)));
            
            VecS(i)=g1;
            VecTH(i)=g2;
            
            VecScomp(i)=VecS1(a(i),b(i));
            VecTHcomp(i)=VecTH1(a(i),b(i));
            
            VecXprime(i)=cos(TH(i)).*VecS(i)-S(i).*sin(TH(i)).*VecTH(i);
            VecYprime(i)=sin(TH(i)).*VecS(i)+S(i).*cos(TH(i)).*VecTH(i);
            
            VecXprimecomp(i)=VecXprime1(a(i),b(i));
            VecYprimecomp(i)=VecYprime1(a(i),b(i));
            
            VecX(i)=VecS(i).*cos(S(i)/R).*cos(TH(i))-R*VecTH(i).*sin(S(i)/R).*sin(TH(i));
            VecY(i)=VecS(i).*cos(S(i)/R).*sin(TH(i))+R*VecTH(i).*sin(S(i)/R).*cos(TH(i));
            VecZ(i)=VecS(i).*sin(S(i)/R);
            
            VecXcomp(i)=VecX1(a(i),b(i));
            VecYcomp(i)=VecY1(a(i),b(i));
            VecZcomp(i)=VecZ1(a(i),b(i));
            
        elseif Sec(j)==2,
            
            %Calculation of closest grid point.
            temp=(U(i)-U2).^2+(V(i)-V2).^2;
            [ind1,ind2] =find(temp==min(min(temp)));
            a(i)=ind1(1);
            b(i)=ind2(1);
            
            %Generation of vectors to compare with
            Ucomp(i)=U2(a(i),b(i));
            Vcomp(i)=V2(a(i),b(i));
            
            plot(Ucomp(i),Vcomp(i),'or',U(i),V(i),'ob');
            
            %Moving data to point on the mesh
            U(i)=Ucomp(i);
            V(i)=Vcomp(i);
            
            VecUcomp(i)=VecU2(a(i),b(i));
            VecVcomp(i)=VecV2(a(i),b(i));
            
            %Converting to other coordinate systems
            S(i)=S2(a(i),b(i));
            TH(i)=TH2(a(i),b(i));
            
            Xprime(i)=Xprime2(a(i),b(i));
            Yprime(i)=Yprime2(a(i),b(i));
            
            X(i)=X2(a(i),b(i));
            Y(i)=Y2(a(i),b(i));
            Z(i)=Z2(a(i),b(i));
            
            %Conversion to other vector fields. 
            [g1,g2] = InverseVec(VecU(i),VecV(i),RHO2(a(i),b(i)),F2(a(i),b(i)),RHOS2(a(i),b(i)),FS2(a(i),b(i)),RHOTH2(a(i),b(i)),FTH2(a(i),b(i)));
            
            VecS(i)=g1;
            VecTH(i)=g2;
            
            VecScomp(i)=VecS2(a(i),b(i));
            VecTHcomp(i)=VecTH2(a(i),b(i));
            
            VecXprime(i)=cos(TH(i)).*VecS(i)-S(i).*sin(TH(i)).*VecTH(i);
            VecYprime(i)=sin(TH(i)).*VecS(i)+S(i).*cos(TH(i)).*VecTH(i);
            
            VecXprimecomp(i)=VecXprime2(a(i),b(i));
            VecYprimecomp(i)=VecYprime2(a(i),b(i));
            
            VecX(i)=VecS(i).*cos(S(i)/R).*cos(TH(i))-R*VecTH(i).*sin(S(i)/R).*sin(TH(i));
            VecY(i)=VecS(i).*cos(S(i)/R).*sin(TH(i))+R*VecTH(i).*sin(S(i)/R).*cos(TH(i));
            VecZ(i)=VecS(i).*sin(S(i)/R);
            
            VecXcomp(i)=VecX2(a(i),b(i));
            VecYcomp(i)=VecY2(a(i),b(i));
            VecZcomp(i)=VecZ2(a(i),b(i));
            
            
        elseif Sec(j)==3,
            %Calculation of closest grid point.
            temp=(U(i)-U3).^2+(V(i)-V3).^2;
            [ind1,ind2] =find(temp==min(min(temp)));
            a(i)=ind1(1);
            b(i)=ind2(1);
            
            %Generation of vectors to compare with
            Ucomp(i)=U3(a(i),b(i));
            Vcomp(i)=V3(a(i),b(i));
            
            plot(Ucomp(i),Vcomp(i),'or',U(i),V(i),'ob');
            
            %Moving data to point on the mesh
            U(i)=Ucomp(i);
            V(i)=Vcomp(i);
            
            VecUcomp(i)=VecU3(a(i),b(i));
            VecVcomp(i)=VecV3(a(i),b(i));
            
            %Converting to other coordinate systems
            S(i)=S3(a(i),b(i));
            TH(i)=TH3(a(i),b(i));
            
            Xprime(i)=Xprime3(a(i),b(i));
            Yprime(i)=Yprime3(a(i),b(i));
            
            X(i)=X3(a(i),b(i));
            Y(i)=Y3(a(i),b(i));
            Z(i)=Z3(a(i),b(i));
            
            %Conversion to other vector fields. 
            [g1,g2] = InverseVec(VecU(i),VecV(i),RHO3(a(i),b(i)),F3(a(i),b(i)),RHOS3(a(i),b(i)),FS3(a(i),b(i)),RHOTH3(a(i),b(i)),FTH3(a(i),b(i)));
            
            VecS(i)=g1;
            VecTH(i)=g2;
            
            VecScomp(i)=VecS3(a(i),b(i));
            VecTHcomp(i)=VecTH3(a(i),b(i));
            
            VecXprime(i)=cos(TH(i)).*VecS(i)-S(i).*sin(TH(i)).*VecTH(i);
            VecYprime(i)=sin(TH(i)).*VecS(i)+S(i).*cos(TH(i)).*VecTH(i);
            
            VecXprimecomp(i)=VecXprime3(a(i),b(i));
            VecYprimecomp(i)=VecYprime3(a(i),b(i));
            
            VecX(i)=VecS(i).*cos(S(i)/R).*cos(TH(i))-R*VecTH(i).*sin(S(i)/R).*sin(TH(i));
            VecY(i)=VecS(i).*cos(S(i)/R).*sin(TH(i))+R*VecTH(i).*sin(S(i)/R).*cos(TH(i));
            VecZ(i)=VecS(i).*sin(S(i)/R);
            
            VecXcomp(i)=VecX3(a(i),b(i));
            VecYcomp(i)=VecY3(a(i),b(i));
            VecZcomp(i)=VecZ3(a(i),b(i));
         
        elseif Sec(j)==4,
            %Calculation of closest grid point.
            temp=(U(i)-U4).^2+(V(i)-V4).^2;
            [ind1,ind2] =find(temp==min(min(temp)));
            a(i)=ind1(1);
            b(i)=ind2(1);
            min(min(temp));
            %Generation of vectors to compare with
            Ucomp(i)=U4(a(i),b(i));
            Vcomp(i)=V4(a(i),b(i));
            
            plot(Ucomp(i),Vcomp(i),'or',U(i),V(i),'ob');
            
            %Moving data to point on the mesh
            U(i)=Ucomp(i);
            V(i)=Vcomp(i);
            VecUcomp(i)=VecU4(a(i),b(i));
            VecVcomp(i)=VecV4(a(i),b(i));
            
            %Converting to other coordinate systems
            S(i)=S4(a(i),b(i));
            TH(i)=TH4(a(i),b(i));
            
            Xprime(i)=Xprime4(a(i),b(i));
            Yprime(i)=Yprime4(a(i),b(i));
            
            X(i)=X4(a(i),b(i));
            Y(i)=Y4(a(i),b(i));
            Z(i)=Z4(a(i),b(i));
            
            %Conversion to other vector fields. 
            [g1,g2] = InverseVec(VecU(i),VecV(i),RHO4(a(i),b(i)),F4(a(i),b(i)),RHOS4(a(i),b(i)),FS4(a(i),b(i)),RHOTH4(a(i),b(i)),FTH4(a(i),b(i)));
            
            VecS(i)=g1;
            VecTH(i)=g2;
            
            VecScomp(i)=VecS4(a(i),b(i));
            VecTHcomp(i)=VecTH4(a(i),b(i));
            
            VecXprime(i)=cos(TH(i)).*VecS(i)-S(i).*sin(TH(i)).*VecTH(i);
            VecYprime(i)=sin(TH(i)).*VecS(i)+S(i).*cos(TH(i)).*VecTH(i);
            
            VecXprimecomp(i)=VecXprime4(a(i),b(i));
            VecYprimecomp(i)=VecYprime4(a(i),b(i));
            
            VecX(i)=VecS(i).*cos(S(i)/R).*cos(TH(i))-R*VecTH(i).*sin(S(i)/R).*sin(TH(i));
            VecY(i)=VecS(i).*cos(S(i)/R).*sin(TH(i))+R*VecTH(i).*sin(S(i)/R).*cos(TH(i));
            VecZ(i)=VecS(i).*sin(S(i)/R);
            
            VecXcomp(i)=VecX4(a(i),b(i));
            VecYcomp(i)=VecY4(a(i),b(i));
            VecZcomp(i)=VecZ4(a(i),b(i));
            
            
        end
    end
end




%% Normalizing Vector Fields
temp=(VecU.^2+VecV.^2).^(1/2);
VecU=VecU./temp;
VecV=VecV./temp;

temp=(VecUcomp.^2+VecVcomp.^2).^(1/2);
VecUcomp=VecUcomp./temp;
VecVcomp=VecVcomp./temp;

temp=(VecS.^2+VecTH.^2).^(1/2);
VecS=VecS./temp;
VecTH=VecTH./temp;

temp=(VecScomp.^2+VecTHcomp.^2).^(1/2);
VecScomp=VecScomp./temp;
VecTHcomp=VecTHcomp./temp;

temp=(VecXprime.^2+VecYprime.^2).^(1/2);
VecXprime=VecXprime./temp;
VecYprime=VecYprime./temp;

temp=(VecXprimecomp.^2+VecYprimecomp.^2).^(1/2);
VecXprimecomp=VecXprimecomp./temp;
VecYprimecomp=VecYprimecomp./temp;

temp=(VecX.^2+VecY.^2+VecZ.^2).^(1/2);
VecX=VecX./temp;
VecY=VecY./temp;
VecZ=VecZ./temp;

temp=(VecXcomp.^2+VecYcomp.^2+VecZcomp.^2).^(1/2);
VecXcomp=VecXcomp./temp;
VecYcomp=VecYcomp./temp;
VecZcomp=VecZcomp./temp;


%% Computing Angles Between Vectors

angleUV=acos(VecU.*VecUcomp+VecV.*VecVcomp);
angleSTH=acos(VecS.*VecScomp+VecTH.*VecTHcomp);
angleSTHGen=acos(VecXprime.*VecXprimecomp+VecYprime.*VecYprimecomp);
angleXYZ=acos(VecX.*VecXcomp+VecY.*VecYcomp+VecZ.*VecZcomp);

figure;
hold on;
plot(angleUV,'o');
plot(angleSTH,'o');
plot(angleSTHGen,'o');
plot(angleXYZ,'o');
% dlmwrite('angleUVdif',angleUV);
% dlmwrite('angleSTHdif',S,TH,VecS,VecTH,angleSTH);
% dlmwrite('angleSTHGendif',Xprime,Yprime,VecXprime,VecYprime,angleSTHGen);
% dlmwrite('angleXYZdif',X,Y,Z,vecX,vecY,vecZ,angleXYZ);


ind=strfind(filedir,'\');
filename=filedir;
filename(ind(end):length(filename))=[];
filename(1:ind(end-1))=[];

UVvecComp.U=U;
UVvecComp.V=V;
UVvecComp.VecU=VecU;
UVvecComp.VecV=VecV;
UVvecComp.VecUcomp=VecUcomp;
UVvecComp.VecVcomp=VecVcomp;
UVvecComp.angleUV=angleUV;

STHvecComp.S=S;
STHvecComp.TH=TH;
STHvecComp.VecS=VecS;
STHvecComp.VecTH=VecTH;
STHvecComp.VecScomp=VecScomp;
STHvecComp.VecTHcomp=VecTHcomp;
STHvecComp.angleSTH=angleSTH;

STHgenvecComp.Xprime=Xprime;
STHgenvecComp.Yprime=Yprime;
STHgenvecComp.VecXprime=VecXprime;
STHgenvecComp.VecYprime=VecYprime;
STHgenvecComp.VecXprimecomp=VecXprimecomp;
STHgenvecComp.VecYprimecomp=VecYprimecomp;
STHgenvecComp.angleSTHGen=angleSTHGen;

XYZvecComp.X=X;
XYZvecComp.Y=Y;
XYZvecComp.Z=Z;
XYZvecComp.VecX=VecX;
XYZvecComp.VecY=VecY;
XYZvecComp.VecZ=VecZ;
XYZvecComp.VecXcomp=VecXcomp;
XYZvecComp.VecYcomp=VecYcomp;
XYZvecComp.VecZcomp=VecZcomp;
XYZvecComp.angleXYZ=angleXYZ;


%Plotting vector fields in UV coordinates
figure;
hold on;
surf(U1,V1,zeros(size(U1,1),size(U1,1)), 'EdgeColor', 'none');
surf(U2,V2,zeros(size(U2,1),size(U2,1)), 'EdgeColor', 'none');
surf(U3,V3,zeros(size(U3,1),size(U3,1)), 'EdgeColor', 'none');
surf(U4,V4,zeros(size(U4,1),size(U4,1)), 'EdgeColor', 'none');
scale=0.4;
quiver(Ucomp,Vcomp,VecUcomp,VecVcomp,scale);
quiver(U,V,VecU,VecV,scale);
hold off;

%Plotting vector fields in STH coordinates
figure;
hold on;
scale=0.2;
quiver(S,TH/(2*pi),VecScomp,VecTHcomp,scale);
quiver(S,TH/(2*pi),VecS,VecTH,scale);
hold off;

%Plotting vector fields in generalized (S,TH) coordinates
figure;
hold on;
scale=0.2;
quiver(Xprime,Yprime,VecXprimecomp,VecYprimecomp,scale);
quiver(Xprime,Yprime,VecXprime,VecYprime,scale);
hold off;

%Plotting vector fields in generalized (X,Y,Z) coordinates
figure;
hold on;
scale=0.2;
quiver3(X,Y,Z,VecXcomp,VecYcomp,VecZcomp,scale);
quiver3(X,Y,Z,VecX,VecY,VecZ,scale);
hold off;

MaxIndex=i;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%       Mapping to "standard" retina.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

StSec1Data=dlmread(['StandardSector1_',num2str(discPoints)]);
StSec2Data=dlmread(['StandardSector2_',num2str(discPoints)]);
StSec3Data=dlmread(['StandardSector3_',num2str(discPoints)]);
StSec4Data=dlmread(['StandardSector4_',num2str(discPoints)]);

n=size(StSec1Data,1);

StRHO1=StSec1Data(1:n,1:n);
StF1=StSec1Data(1:n,n+1:2*n);
StS1=StSec1Data(1:n,2*n+1:3*n);
StTH1=StSec1Data(1:n,3*n+1:4*n);

StU1=StRHO1.*cos(StF1);
StV1=StRHO1.*sin(StF1);

%Calcution of derivatives
ds=StS1(1,2)-StS1(1,1);
DS=DiffX(n)/ds;
StRHO1S=(DS*StRHO1')';
StF1S=(DS*StF1')';

dth=StTH1(2,1)-StTH1(1,1);
DTH=DiffX(n)/dth;
StRHO1TH=(DTH*StRHO1);
StF1TH=(DTH*StF1);

StRHO2=StSec2Data(1:n,1:n);
StF2=StSec2Data(1:n,n+1:2*n);
StS2=StSec2Data(1:n,2*n+1:3*n);
StTH2=StSec2Data(1:n,3*n+1:4*n);

StU2=StRHO2.*cos(StF2);
StV2=StRHO2.*sin(StF2);

%Calcution of derivatives
ds=StS2(1,2)-StS2(1,1);
DS=DiffX(n)/ds;
StRHO2S=(DS*StRHO2')';
StF2S=(DS*StF2')';

dth=StTH2(2,1)-StTH2(1,1);
DTH=DiffX(n)/dth;
StRHO2TH=(DTH*StRHO2);
StF2TH=(DTH*StF2);

StRHO3=StSec3Data(1:n,1:n);
StF3=StSec3Data(1:n,n+1:2*n);
StS3=StSec3Data(1:n,2*n+1:3*n);
StTH3=StSec3Data(1:n,3*n+1:4*n);

StU3=StRHO3.*cos(StF3);
StV3=StRHO3.*sin(StF3);

%Calcution of derivatives
ds=StS3(1,2)-StS3(1,1);
DS=DiffX(n)/ds;
StRHO3S=(DS*StRHO3')';
StF3S=(DS*StF3')';

dth=StTH3(2,1)-StTH3(1,1);
DTH=DiffX(n)/dth;
StRHO3TH=(DTH*StRHO3);
StF3TH=(DTH*StF3);

StRHO4=StSec4Data(1:n,1:n);
StF4=StSec4Data(1:n,n+1:2*n);
StS4=StSec4Data(1:n,2*n+1:3*n);
StTH4=StSec4Data(1:n,3*n+1:4*n);

StU4=StRHO4.*cos(StF4);
StV4=StRHO4.*sin(StF4);

%Calcution of derivatives
ds=StS4(1,2)-StS4(1,1);
DS=DiffX(n)/ds;
StRHO4S=(DS*StRHO4')';
StF4S=(DS*StF4')';

dth=StTH4(2,1)-StTH4(1,1);
DTH=DiffX(n)/dth;
StRHO4TH=(DTH*StRHO4);
StF4TH=(DTH*StF4);

for i=1:MaxIndex,
    angle=mod(TH(i),2*pi);
    if angle<pi/2,
        
          %Calculation of closest grid point in S,TH coordinates.
            temp=(S(i)-StS1).^2+(TH(i)-StTH1).^2;
            [ind1,ind2] =find(temp==min(min(temp)));
            a(i)=ind1(1);
            b(i)=ind2(1);
            
            USt(i)=StRHO1(a(i),b(i))*cos(StF1(a(i),b(i)));
            VSt(i)=StRHO1(a(i),b(i))*sin(StF1(a(i),b(i)));
            
            VecUSt(i)=VecS(i).*(StRHO1S(a(i),b(i)).*cos(StF1(a(i),b(i)))-StRHO1(a(i),b(i)).*StF1S(a(i),b(i)).*sin(StF1(a(i),b(i))))+VecTH(i).*(StRHO1TH(a(i),b(i)).*cos(StF1(a(i),b(i)))-StRHO1(a(i),b(i)).*StF1TH(a(i),b(i)).*sin(StF1(a(i),b(i))));
            VecVSt(i)=VecS(i).*(StRHO1S(a(i),b(i)).*sin(StF1(a(i),b(i)))+StRHO1(a(i),b(i)).*StF1S(a(i),b(i)).*cos(StF1(a(i),b(i))))+VecTH(i).*(StRHO1TH(a(i),b(i)).*sin(StF1(a(i),b(i)))+StRHO1(a(i),b(i)).*StF1TH(a(i),b(i)).*cos(StF1(a(i),b(i))));
    
            VecUStcomp(i)=VecScomp(i).*(StRHO1S(a(i),b(i)).*cos(StF1(a(i),b(i)))-StRHO1(a(i),b(i)).*StF1S(a(i),b(i)).*sin(StF1(a(i),b(i))))+VecTHcomp(i).*(StRHO1TH(a(i),b(i)).*cos(StF1(a(i),b(i)))-StRHO1(a(i),b(i)).*StF1TH(a(i),b(i)).*sin(StF1(a(i),b(i))));
            VecVStcomp(i)=VecScomp(i).*(StRHO1S(a(i),b(i)).*sin(StF1(a(i),b(i)))+StRHO1(a(i),b(i)).*StF1S(a(i),b(i)).*cos(StF1(a(i),b(i))))+VecTHcomp(i).*(StRHO1TH(a(i),b(i)).*sin(StF1(a(i),b(i)))+StRHO1(a(i),b(i)).*StF1TH(a(i),b(i)).*cos(StF1(a(i),b(i))));
    
    elseif angle<pi,
          %Calculation of closest grid point in S,TH coordinates.
            temp=(S(i)-StS2).^2+(TH(i)-StTH2).^2;
            [ind1,ind2] =find(temp==min(min(temp)));
            a(i)=ind1(1);
            b(i)=ind2(1);
            
            USt(i)=StRHO2(a(i),b(i))*cos(StF2(a(i),b(i)));
            VSt(i)=StRHO2(a(i),b(i))*sin(StF2(a(i),b(i)));
            
            VecUSt(i)=VecS(i).*(StRHO2S(a(i),b(i)).*cos(StF2(a(i),b(i)))-StRHO2(a(i),b(i)).*StF2S(a(i),b(i)).*sin(StF2(a(i),b(i))))+VecTH(i).*(StRHO2TH(a(i),b(i)).*cos(StF2(a(i),b(i)))-StRHO2(a(i),b(i)).*StF2TH(a(i),b(i)).*sin(StF2(a(i),b(i))));
            VecVSt(i)=VecS(i).*(StRHO2S(a(i),b(i)).*sin(StF2(a(i),b(i)))+StRHO2(a(i),b(i)).*StF2S(a(i),b(i)).*cos(StF2(a(i),b(i))))+VecTH(i).*(StRHO2TH(a(i),b(i)).*sin(StF2(a(i),b(i)))+StRHO2(a(i),b(i)).*StF2TH(a(i),b(i)).*cos(StF2(a(i),b(i))));
      
             VecUStcomp(i)=VecScomp(i).*(StRHO2S(a(i),b(i)).*cos(StF2(a(i),b(i)))-StRHO2(a(i),b(i)).*StF2S(a(i),b(i)).*sin(StF2(a(i),b(i))))+VecTHcomp(i).*(StRHO2TH(a(i),b(i)).*cos(StF2(a(i),b(i)))-StRHO2(a(i),b(i)).*StF2TH(a(i),b(i)).*sin(StF2(a(i),b(i))));
            VecVStcomp(i)=VecScomp(i).*(StRHO2S(a(i),b(i)).*sin(StF2(a(i),b(i)))+StRHO2(a(i),b(i)).*StF2S(a(i),b(i)).*cos(StF2(a(i),b(i))))+VecTHcomp(i).*(StRHO2TH(a(i),b(i)).*sin(StF2(a(i),b(i)))+StRHO2(a(i),b(i)).*StF2TH(a(i),b(i)).*cos(StF2(a(i),b(i))));
            
    elseif angle<3*pi/2,
          %Calculation of closest grid point in S,TH coordinates.
            temp=(S(i)-StS3).^2+(TH(i)-StTH3).^2;
            [ind1,ind2] =find(temp==min(min(temp)));
            a(i)=ind1(1);
            b(i)=ind2(1);
            
            USt(i)=StRHO3(a(i),b(i))*cos(StF3(a(i),b(i)));
            VSt(i)=StRHO3(a(i),b(i))*sin(StF3(a(i),b(i)));
            
            VecUSt(i)=VecS(i).*(StRHO3S(a(i),b(i)).*cos(StF3(a(i),b(i)))-StRHO3(a(i),b(i)).*StF3S(a(i),b(i)).*sin(StF3(a(i),b(i))))+VecTH(i).*(StRHO3TH(a(i),b(i)).*cos(StF3(a(i),b(i)))-StRHO3(a(i),b(i)).*StF3TH(a(i),b(i)).*sin(StF3(a(i),b(i))));
           VecVSt(i)=VecS(i).*(StRHO3S(a(i),b(i)).*sin(StF3(a(i),b(i)))+StRHO3(a(i),b(i)).*StF3S(a(i),b(i)).*cos(StF3(a(i),b(i))))+VecTH(i).*(StRHO3TH(a(i),b(i)).*sin(StF3(a(i),b(i)))+StRHO3(a(i),b(i)).*StF3TH(a(i),b(i)).*cos(StF3(a(i),b(i))));        
   
           VecUStcomp(i)=VecScomp(i).*(StRHO3S(a(i),b(i)).*cos(StF3(a(i),b(i)))-StRHO3(a(i),b(i)).*StF3S(a(i),b(i)).*sin(StF3(a(i),b(i))))+VecTHcomp(i).*(StRHO3TH(a(i),b(i)).*cos(StF3(a(i),b(i)))-StRHO3(a(i),b(i)).*StF3TH(a(i),b(i)).*sin(StF3(a(i),b(i))));
            VecVStcomp(i)=VecScomp(i).*(StRHO3S(a(i),b(i)).*sin(StF3(a(i),b(i)))+StRHO3(a(i),b(i)).*StF3S(a(i),b(i)).*cos(StF3(a(i),b(i))))+VecTHcomp(i).*(StRHO3TH(a(i),b(i)).*sin(StF3(a(i),b(i)))+StRHO3(a(i),b(i)).*StF3TH(a(i),b(i)).*cos(StF3(a(i),b(i))));        
   
    else
          %Calculation of closest grid point in S,TH coordinates.
            temp=(S(i)-StS4).^2+(TH(i)-StTH4).^2;
            [ind1,ind2] =find(temp==min(min(temp)));
            a(i)=ind1(1);
            b(i)=ind2(1);
            
            USt(i)=StRHO4(a(i),b(i))*cos(StF4(a(i),b(i)));
            VSt(i)=StRHO4(a(i),b(i))*sin(StF4(a(i),b(i)));
            
            VecUSt(i)=VecS(i).*(StRHO4S(a(i),b(i)).*cos(StF4(a(i),b(i)))-StRHO4(a(i),b(i)).*StF4S(a(i),b(i)).*sin(StF4(a(i),b(i))))+VecTH(i).*(StRHO4TH(a(i),b(i)).*cos(StF4(a(i),b(i)))-StRHO4(a(i),b(i)).*StF4TH(a(i),b(i)).*sin(StF4(a(i),b(i))));
            VecVSt(i)=VecS(i).*(StRHO4S(a(i),b(i)).*sin(StF4(a(i),b(i)))+StRHO4(a(i),b(i)).*StF4S(a(i),b(i)).*cos(StF4(a(i),b(i))))+VecTH(i).*(StRHO4TH(a(i),b(i)).*sin(StF4(a(i),b(i)))+StRHO4(a(i),b(i)).*StF4TH(a(i),b(i)).*cos(StF4(a(i),b(i))));   
        
            VecUStcomp(i)=VecScomp(i).*(StRHO4S(a(i),b(i)).*cos(StF4(a(i),b(i)))-StRHO4(a(i),b(i)).*StF4S(a(i),b(i)).*sin(StF4(a(i),b(i))))+VecTHcomp(i).*(StRHO4TH(a(i),b(i)).*cos(StF4(a(i),b(i)))-StRHO4(a(i),b(i)).*StF4TH(a(i),b(i)).*sin(StF4(a(i),b(i))));
            VecVStcomp(i)=VecScomp(i).*(StRHO4S(a(i),b(i)).*sin(StF4(a(i),b(i)))+StRHO4(a(i),b(i)).*StF4S(a(i),b(i)).*cos(StF4(a(i),b(i))))+VecTHcomp(i).*(StRHO4TH(a(i),b(i)).*sin(StF4(a(i),b(i)))+StRHO4(a(i),b(i)).*StF4TH(a(i),b(i)).*cos(StF4(a(i),b(i))));   
        
    end
end
    
figure;
temp=(VecUSt.^2+VecVSt.^2).^(1/2);
VecUSt=VecUSt./temp;
VecVSt=VecVSt./temp;

temp=(VecUStcomp.^2+VecVStcomp.^2).^(1/2);
VecUStcomp=VecUStcomp./temp;
VecVStcomp=VecVStcomp./temp;


%Plotting vector fields in Standard UV coordinates
figure;
hold on;
surf(StU1,StV1,zeros(size(StU1,1),size(StU1,1)), 'EdgeColor', 'none');
surf(StU2,StV2,zeros(size(StU2,1),size(StU2,1)), 'EdgeColor', 'none');
surf(StU3,StV3,zeros(size(StU3,1),size(StU3,1)), 'EdgeColor', 'none');
surf(StU4,StV4,zeros(size(StU4,1),size(StU4,1)), 'EdgeColor', 'none');
scale=0.4;

quiver(USt,VSt,VecUStcomp,VecVStcomp,scale);
quiver(USt,VSt,VecUSt,VecVSt,scale);

angleUVSt=acos(VecUSt.*VecUStcomp+VecVSt.*VecVStcomp);


UVStvecComp.USt=USt;
UVStvecComp.VSt=VSt;
UVStvecComp.VecUSt=VecUSt;
UVStvecComp.VecVSt=VecVSt;
UVStvecComp.VecUStcomp=VecUStcomp;
UVStvecComp.VecVStcomp=VecVStcomp;
UVStvecComp.angleUVSt=angleUVSt;


save(['vecComp_',num2str(discPoints),'_',cellType,'_',fieldType,'_',filename,'.mat'],'UVvecComp','STHvecComp','STHgenvecComp','XYZvecComp','UVStvecComp');

% dlmwrite('angleStUVdif',angleStUV);

hold off;

end

